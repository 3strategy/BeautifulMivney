---
layout: page
title: "ex3a.2 שרשרת חוליות"
subtitle: "Node<T> תרגילים עם דרישות רקורסיה"
tags: []
lang: he
---





## 3a2.1 בניית ברקורסיה של שרשרת מ-1 עד n {#id3a2.1}

עליכם לממש פונקציה רקורסיבית בשם `Build1toNListRec` אשר מקבלת מספר שלם `n` כפרמטר. הפונקציה צריכה לבנות רשימה מקושרת שאיבריה הם המספרים מ-`n` ועד `1` (בסדר עולה!!!) ולהחזיר את ראש הרשימה.

### דרישות:

1. רקורסיה: חובה להשתמש בגישה רקורסיבית לפתרון הבעיה.
2. מקרה בסיס: טפלו במקרה שבו n קטן או שווה ל-0. במקרה זה, הפונקציה צריכה להחזיר null (רשימה ריקה).
3. בניית הרשימה: הרשימה צריכה להיבנות כך שהרשימה בסדר עולה מ 1 ועד המספר שהתקבל כפרמטר
4. 



## 3a2.2 הסרת האיבר הראשון המכיל את הערך {#id3a2.2}

עליכם לממש פונקציה רקורסיבית בשם `RemoveNum` אשר מקבלת שני פרמטרים:

1. head - מצביע לראש רשימה מקושרת של מספרים שלמים (מסוג Node
2. numToRemove - המספר השלם שיש להסיר את החוליה הראשונה המכילה אותו.

הפונקציה צריכה להסיר את החוליה הראשונה ברשימה המכילה את `numToRemove` ולהחזיר את הראש החדש של הרשימה.

### דגשים:

1. הפונקציה חייבת להיות רקורסיבית.
2. הסיבוכיות הרצויה היא יעילה ככל הניתן (לדוגמה, O(n) במקרה הגרוע).
3. יש לטפל במקרה שבו הרשימה ריקה (head הוא null).
4. יש לטפל במקרה שבו המספר להסרה נמצא בחוליה הראשונה.
5. יש לטפל במקרה שבו המספר להסרה לא נמצא ברשימה כלל.


## 3a2.3 מציאת מקסימאלי רקורסיבית {#id3a2.3}

**יחסית פשוט**


עליכם לממש פונקציה רקורסיבית בשם `MaxMemberRec` אשר מקבלת פרמטר אחד:

1. head - מצביע לראש רשימה מקושרת של מספרים שלמים (מסוג Node

הפונקציה צריכה להחזיר את הערך המקסימלי מבין כל האיברים ברשימה המקושרת.

דגשים:

1. הפונקציה חייבת להיות רקורסיבית.
2. השתמשו במחלקה Node מתוך Unit4.CollectionsLib.
3. מקרה בסיס: אם הרשימה מכילה איבר אחד בלבד, הוא המקסימום. אם הרשימה ריקה, אין מקסימום (ניתן להחזיר ערך מינימלי כלשהו או לזרוק חריגה, אך לצורך תרגיל זה, נניח שהרשימה אינה ריקה או שתטופל על ידי קוד הבדיקה).

## 3a2.4 הסרת כל השליליים רקורסיבית {#id3a2.4}

**די קשה**


עליכם לממש פונקציה רקורסיבית בשם `RemoveNegative` אשר מקבלת פרמטר אחד:

1. head - מצביע לראש רשימה מקושרת של מספרים שלמים (מסוג Node).

הפונקציה צריכה להסיר את כל המספרים השליליים מהרשימה המקושרת ולהחזיר את הראש החדש של הרשימה לאחר ההסרה.

### דגשים:

1. הפתרון חייב להיות רקורסיבי.
2. יש להשתמש במחלקת Node מהספרייה Unit4.CollectionsLib.
3. הפונקציה צריכה להחזיר את הראש החדש של הרשימה.

### קוד עזר:



## 3a2.5 סכום שרשרת {#id3a2.5}

עליכם לממש פונקציה רקורסיבית בשם `SumLinkedListRecursive` אשר מקבלת פרמטר אחד:

1. head - מצביע לראש הרשימה המקושרת (מסוג Node

הפונקציה צריכה לחשב ולהחזיר את הסכום של כל האיברים ברשימה המקושרת באמצעות רקורסיה.

### דגשים:

1. מקרה בסיס: אם הרשימה ריקה (כלומר, head הוא null), הפונקציה צריכה להחזיר 0.
2. מקרה רקורסיבי: סכום הרשימה הוא ערך החוליה הנוכחית בתוספת סכום שאר הרשימה (הזנב).
3. הקפידו לא לשנות את מבנה הרשימה המקורית במהלך החישוב.


## 3a2.6 כמות הזוגיים {#id3a2.6}

עליכם לממש פונקציה רקורסיבית בשם `CountEvenNodes` אשר מקבלת פרמטר אחד:

1. head - מצביע לראש רשימה מקושרת של מספרים שלמים מסוג Node

הפונקציה צריכה להחזיר את כמות האיברים הזוגיים ברשימה המקושרת.

### דגשים:

1. יש לממש את הפונקציה באופן רקורסיבי.