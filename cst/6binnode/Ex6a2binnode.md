---
layout: page
title: "ex6a2 עצים בינאריים BinNode⟨T⟩"
subtitle: "עצים בינאריים: BinNode⟨T⟩ תרגול 6a2"
tags: []
courseName: "מבני נתונים"
unitTopic: "עצים בינאריים"
lang: he
---


## 6a2.1 בדיקת ערכים אי-זוגיים בעץ בינארי {#id6a2.1}

עליכם לממש פונקציה חיצונית בשם `AllValuesAreOdd` אשר מקבלת פרמטר אחד:

1. t - עץ בינארי (מסוג BinNode) שהצמתים שלו הם מטיפוס שלם.

הפונקציה צריכה להחזיר `true` אם העץ מכיל אך ורק ערכים אי-זוגיים, ו-`false` אם הוא מכיל לפחות ערך זוגי אחד.

### דגשים

1. השתמשו ברקורסיה כדי לעבור על כל צומתי העץ.
2. בדקו כל ערך בצומת: אם הוא זוגי, החזירו false מיד.
3. אם הגעתם לסוף ענף (צומת null) מבלי למצוא ערך זוגי, המשמעות היא שהענף הזה מכיל רק ערכים אי-זוגיים (או שהוא ריק).

### דוגמאות

1. עבור העץ:

    ```mermaid
    flowchart TB
      A((1)) --> B((3)):::leaf
      A --> C((5)):::leaf
    ```

    הפונקציה תחזיר: true

1. עבור העץ:

    ```mermaid
    flowchart TB
      A((1)) --> B((2)):::leaf
      A --> C((5)):::leaf
    ```

    הפונקציה תחזיר: false (בגלל הערך 2)

1. עבור העץ:

    ```mermaid
    flowchart TB
      A((7)) --> B((9))
      A --> C((11)):::leaf
      B --> D((13)):::leaf
      B --> E((15)):::leaf
    ```

    הפונקציה תחזיר: true

## 6a2.2 בדיקת זוגות אחים בעץ בינארי {#id6a2.2}

עליכם לממש פונקציה בשם `HasIdenticalSiblings` אשר מקבלת BinNode⟨int⟩ tree המצביע לשורש של עץ בינארי

דמיינו שאתם מנהלים בסיס נתונים של עץ בינארי, כמו למשל היררכיה של קבצים במערכת הפעלה או מבנה נתונים של אובייקטים במשחק מחשב. לעיתים קרובות, אתם רוצים לוודא שאין כפילויות לא רצויות או חריגות מסוימות בנתונים. מציאת אחים עם ערכים זהים יכולה להצביע על שגיאה, כפילות מידע, או צורך באופטימיזציה. תרגיל זה מדמה מצב כזה, ומאפשר לכם לזהות בעיות פוטנציאליות במבני נתונים היררכיים.

הפונקציה צריכה לבדוק האם קיים בעץ זוג כלשהו של אחים (כלומר, שני צמתים עם אותו הורה) שלהם ערכים זהים.

- אם נמצא זוג כזה של אחים עם ערכים זהים, הפונקציה צריכה להחזיר `true`.
- אם לא נמצא אף זוג כזה בכל העץ, הפונקציה צריכה להחזיר `false`.

**הערה**: עץ בינארי הוא עץ שבו לכל צומת יש לכל היותר שני ילדים (בן שמאלי ובן ימני).

### קלט

הפונקציה תקבל עצם מסוג BinNode המייצג את שורש העץ הבינארי.

### פלט

הפונקציה תחזיר ערך בוליאני (`bool`): `true` אם נמצאו אחים בעלי ערך זהה, ו-`false` אחרת. הפונקציה לא תדפיס דבר.

### דוגמאות

1. קלט: Tree:

    ```mermaid
    flowchart TB
      A((10)) --> B((5))
      A --> C((5))
      B --> D((1)):::leaf
      B --> E((2)):::leaf
      C --> F((3)):::leaf
      C --> G((4)):::leaf
    ```

      פלט : true

1. קלט: Tree:

    ```mermaid
    flowchart TB
      A((10)) --> B((5))
      A --> C((8))
      B --> D((1)):::leaf
      B --> E((2)):::leaf
      C --> F((3)):::leaf
      C --> G((4)):::leaf
    ```

    פלט : false

1. קלט: Tree:

    ```mermaid
    flowchart TB
      A((10)) --> B((5))
      A --> C((6))
      B --> D((1)):::leaf
      B --> E((1)):::leaf
      C --> F((3)):::leaf
      C --> G((4)):::leaf
    ```

    פלט : true

1. קלט: Tree:

    ```mermaid
    flowchart TB
      A((10)) --> B((5)):::leaf
      A --> C((6)):::leaf
    ```

    פלט : false

1. קלט: Tree:

    ```mermaid
    flowchart TB
      A((10)):::leaf
    ```

    פלט : false

1. קלט: Tree: null  
    פלט : false

## 6a2.3 בדיקת ערך עלים מול ערך אב בעץ בינארי {#id6a2.3}

עליכם לממש פונקציה בשם `AreLeavesEqualToParent` אשר מקבלת BinNode⟨int⟩ tree המצביע לשורש של עץ בינארי

הפונקציה צריכה להחזיר `true` אם ערכם של כל העלים בעץ זהה לערך של אביהם, ו-`false` אם לא.

### הנחיות

1. עליכם להשתמש בפונקציית עזר (helper function) רקורסיבית שתעבור על העץ.
2. פונקציית העזר צריכה לקבל את הצומת הנוכחי ואת ערך האב של הצומת הנוכחי.
3. אם הצומת הוא עלה (אין לו ילד שמאלי ואין לו ילד ימני), בדקו האם ערכו שווה לערך האב שהועבר לפונקציה.
4. אם הצומת אינו עלה, קראו באופן רקורסיבי עבור ילדיו, כאשר ערך האב עבור הילדים הוא ערך הצומת הנוכחי.
5. שימו לב למקרה של עץ ריק או עץ עם צומת בודד (שהוא גם עלה וגם שורש) - במקרים אלו, התנאי נחשב כמתקיים.

### שימוש במחלקות

לצורך פתרון התרגיל, עליכם להשתמש ב-`BinNode`.

### דוגמאות

1. עץ שבו כל עלה שווה לערך אביו:

    ```mermaid
    flowchart TB
      A((10)) --> B((5))
      A --> C((10))
      B --> D((5)):::leaf
      B --> E((5)):::leaf
      C --> F((10)):::leaf
    ```

    הפונקציה תחזיר: true

1. עץ שבו עלה אחד אינו שווה לערך אביו:

    ```mermaid
    flowchart TB
      A((10)) --> B((5))
      A --> C((10))
      B --> D((5)):::leaf
      B --> E((6)):::leaf
      C --> F((10)):::leaf
    ```

    הפונקציה תחזיר: false

1. עץ עם עלה בודד שהוא גם השורש (אין לו אב):

    ```mermaid
    flowchart TB
      A((7)):::leaf
    ```

    הפונקציה תחזיר: true (אין עלים שאינם השורש, ולכן התנאי מתקיים באופן טריוויאלי).

1. עץ ריק:

    עץ: null

    הפונקציה תחזיר: true (אין עלים לבדוק).

## 6a2.4 עץ יוני {#id6a2.4}

עליכם לממש פונקציה בשם `IsYoniTree` אשר מקבלת BinNode⟨int⟩ tree המצביע לשורש של עץ בינארי

הפונקציה צריכה להחזיר `true` אם העץ הנתון הוא 'עץ יוני', ו-`false` אם לא.

### הגדרת 'עץ יוני'

'עץ יוני' מוגדר באופן רקורסיבי כך:

1. עלה (צומת ללא בנים) הוא 'עץ יוני'.
2. עץ ששני בניו (הבן השמאלי והבן הימני) הם בעצמם 'עצי יוני' הוא גם 'עץ יוני'.

### דרישות

1. הפונקציה חייבת להיות חיצונית (לא מתודה של המחלקה BinNode).
2. השתמשו במחלקת BinNode עבור העץ הבינארי.

### שימו לב

1. עץ שיש לו רק בן אחד (שמאלי או ימני) אינו עץ יוני (אלא אם כן הוא עלה).

## 6a2.5 בדיקת צומת עם בנים שונים בעץ בינארי {#id6a2.5}

עליכם לממש פונקציה בשם `HasDifferentChildren` שמקבלת שורש של עץ בינארי (`BinNode<int> t`) ומחזירה `true` אם יש בעץ צומת שיש לו גם ילד שמאלי וגם ילד ימני והערכים של הילדים שונים זה מזה. אם אין אף צומת כזה, הפונקציה תחזיר `false`.

### דגשים

1. עץ ריק (t == null) מחזיר `false` – אין בו צמתים.
2. אם בצומת הנוכחי קיימים שני ילדים שערכיהם שונים, ניתן להחזיר מיד `true`.
3. אחרת המשיכו לחפש רקורסיבית בשני תתי־העצים וחזירו `true` אם אחד מהם מכיל צומת מתאים.

### דוגמאות

1. עץ שבו הערכים שונים:

    ```mermaid
    flowchart TB
      A((10)) --> B((5)):::leaf
      A --> C((8)):::leaf
    ```

    הפונקציה תחזיר: `true` (הילדים 5 ו־8 שונים).

2. עץ שבו הערכים זהים:

    ```mermaid
    flowchart TB
      A((4)) --> B((4)):::leaf
      A --> C((4)):::leaf
    ```

    הפונקציה תחזיר: `false` (אין צומת עם שני בנים שונים).

## 6a2.6 בדיקת צומת ללא בנים שונים בעץ בינארי {#id6a2.6}

עליכם לממש פונקציה בשם `HasNoDifferentChildren` שמחזירה `true` אם **לא קיים** בעץ צומת עם שני ילדים שערכיהם שונים זה מזה. כלומר, עבור כל צומת שיש לו שני בנים – הערכים שלהם זהים; אם נמצא צומת שבו הערכים שונים, הפונקציה תחזיר `false`.

### דגשים

1. עץ ריק (t == null) מחזיר `true` – אין בו הפרות.
2. אם בצומת הנוכחי יש שני ילדים שערכיהם שונים, החזירו מיד `false`.
3. אחרת המשיכו לבדוק רקורסיבית את שני תתי־העצים, והחזירו `true` רק אם שני הצדדים עוברים את הבדיקה.

### דוגמאות

1. עץ שעומד בתנאי:

    ```mermaid
    flowchart TB
      A((7)) --> B((7)):::leaf
      A --> C((7)):::leaf
    ```

    הפונקציה תחזיר: `true` (הילדים בכל צומת זהים או חסרים).

2. עץ שלא עומד בתנאי:

    ```mermaid
    flowchart TB
      A((3)) --> B((1)):::leaf
      A --> C((9)):::leaf
    ```

    הפונקציה תחזיר: `false` (לשורש שני בנים שונים).

## 6a2.7  עץ יחיאל {#id6a2.7}

עליכם לממש פונקציה חיצונית בשם `IsYechielTree` אשר מקבלת פרמטר אחד:

1. BinNode(t)

הפונקציה צריכה להחזיר `true` אם העץ הוא 'עץ יחיאל', ו-`false` אחרת.

### הגדרת 'עץ יחיאל'

1. עלה (צומת ללא בנים) הוא תמיד עץ יחיאל.
2. עץ שאינו עלה הוא עץ יחיאל אם מתקיימים שני התנאים הבאים:
3. ערך שורש העץ שווה לסכום ערכי בניו (אם קיים בן יחיד, ערך השורש שווה לערך הבן).
4. כל אחד מבניו (הבן השמאלי והבן הימני, אם קיימים) הוא גם עץ יחיאל בפני עצמו.

### דגשים

1. השתמשו בגישה רקורסיבית לפתרון הבעיה.
2. יש לטפל במקרים שבהם לצומת יש רק בן שמאלי או רק בן ימני.

## 6a2.8 עץ סחי {#id6a2.8}

עליכם לממש פונקציה חיצונית בשם `IsSachiTree` אשר מקבלת BinNode⟨int⟩ tree המצביע לשורש של עץ בינארי

הפונקציה צריכה להחזיר `true` אם העץ הינו עץ סחי, ו-`false` אם לא.

### הגדרת עץ סחי

עץ בינארי יקרא "סחי" אם מתקיים אחד מהתנאים הבאים:

1. העץ הוא עלה (כלומר, אין לו בנים).
2. ערכו של העץ זהה לערכו של לפחות אחד מבניו, ואותו בן הינו עץ סחי בעצמו.

### דגשים

1. השתמשו ברקורסיה כדי לפתור את הבעיה.
2. עליכם להשתמש במחלקת BinNode עבור העץ הבינארי.

## 6a2.9 בדיקת עץ בינארי מיוחד {#id6a2.9}

עליכם לממש פונקציה חיצונית בשם `CheckSpecialBinaryTree` אשר מקבלת פרמטר אחד:

1. t - עץ בינארי מטיפוס BinNode

הפונקציה צריכה להחזיר `true` אם העץ עומד בשני התנאים הבאים עבור כל צומת:

1. הערך של צומת ימני קטן מהערך של אביו.
2. הערך של צומת שמאלי גדול מהערך של אביו.

אם אחד מהתנאים הללו לא מתקיים עבור צומת כלשהו בעץ, הפונקציה צריכה להחזיר `false`.

### דגשים

1. השתמשו במחלקה BinNode.
2. הפונקציה צריכה להיות חיצונית (לא חלק ממחלקת BinNode).
3. עליכם לטפל במקרה של עץ ריק (null).
4. השתמשו בשיטה רקורסיבית לפתרון הבעיה.

## 6a2.10 בדיקת עץ ליה {#id6a2.10}

עליכם לממש פעולה חיצונית (פונקציה סטטית) בשם `IsLiaTree` אשר מקבלת פרמטר אחד:

1. T - עץ בינארי (BinNode

הפעולה צריכה להחזיר `true` אם העץ הינו 'עץ ליה', ו`false` אם לא.

### הגדרת 'עץ ליה'

עץ בינארי ייקרא 'עץ ליה' אם לכל צומת בעץ שיש לו נכד (כלומר, צומת שנמצא במרחק של שני קשרים או יותר מהצומת הנוכחי), יש לו בן יחיד (כלומר, או רק בן ימני או רק בן שמאלי, אך לא שניהם).

### דגשים למימוש

1. הפונקציה צריכה לבדוק את התנאי באופן רקורסיבי או איטרטיבי על כל הצמתים בעץ.
2. שימו לב למקרי קצה של צמתים ללא בנים או עם בן אחד בלבד.
3. אם צומת כלשהו מפר את התנאי, הפונקציה צריכה להחזיר false מיד.
4. אם כל הצמתים מקיימים את התנאי, הפונקציה תחזיר true.

### שימוש במחלקות עזר

לצורך פתרון התרגיל, עליכם להשתמש במחלקות `BinNode`.
