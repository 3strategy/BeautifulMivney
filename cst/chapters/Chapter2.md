---
layout: page 
title: "פרק 2 – יעילות וסיבוכיות"
subtitle: "הבנת זמן ריצה, משאבים ו‑Big‑O"
tags: [סיבוכיות, יעילות, BigO, זמן ריצה, אנליזה אסימפטוטית, מדעי המחשב]
mathjax: true
lang: he
---

{: .box-note}
כאשר מנתחים מבני נתונים ואלגוריתמים חשוב לדעת לא רק מה הם עושים אלא גם כמה משאבים הם צורכים. בפרק זה נלמד להעריך את **יעילות** האלגוריתם (כמה זמן וזיכרון הוא צורך בפועל) ולמדוד את **סיבוכיותו** – תיאור אסימפטוטי של התלות בגודל הקלט.


<!-- Source: University of Wisconsin – Complexity & Big‑O notes; University of Tennessee – Big‑O overview -->
<!-- https://pages.cs.wisc.edu/~vernon/cs367/notes/3.COMPLEXITY.html#:~:text=An%20important%20question%20is%3A%20How,covers%20lots%20of%20resources%2C%20including -->

<!-- https://userpages.cs.umbc.edu/chang/cs202.f98/readings/recursion.html#:~:text=Recursion%20is%20a%20technique%20that,sum%20of%20that%20many%20numbers -->

## מה ההבדל בין יעילות לסיבוכיות?

<details markdown="1">
<summary>הגדרת יעילות</summary>

**יעילות** (Performance) בודקת את הזמן, הזיכרון ומשאבים אחרים שהאלגוריתם צורך במערכת מסוימת. למשל, כמה שניות לוקח לאלגוריתם לרוץ על מחשב ספציפי וכמה זיכרון RAM הוא משתמש. יעילות מושפעת מפרטי החומרה, שפת התכנות ומהמימוש.

</details>

<details markdown="1">
<summary>הגדרת סיבוכיות</summary>

**סיבוכיות** היא מדד תאורטי המתאר כיצד זמן הריצה או השימוש במשאבים גדל עם גודל הקלט. סיבוכיות נמדדת לרוב ב‑Big‑O, המתארת חסם עליון אסימפטוטי – כלומר, איך האלגוריתם מתנהג כאשר גודל הקלט שואף לאינסוף. סיבוכיות אינה תלויה בפרטי החומרה.

</details>

### סיבוכיות זמני ריצה נפוצות

{: .subq}
א. **O(1) – זמן קבוע:** זמן הריצה אינו תלוי בגודל הקלט. למשל, גישה לאיבר במערך לפי אינדקס.  
{: .subq}
ב. **O(log n) – לוגריתמית:** פעולות שמקטינות את הבעיה פי שניים בכל צעד, כמו חיפוש בינארי.  
{: .subq}
ג. **O(n) – ליניארית:** זמן הריצה גדל ביחס ישיר לגודל הקלט – למשל מעבר על כל איברי המערך.  
{: .subq}
ד. **O(n log n) – ליניארי לוגריתמי:** אלגוריתמים מהירים למיון (כמו Merge Sort).  
{: .subq}
ה. **O(n²) – ריבועית:** אלגוריתמים שמבצעים לולאה בתוך לולאה (כמו Bubble Sort).  
{: .subq}
ו. **גדולות יותר:** O(2ⁿ) או O(n!) – בדרך כלל לא יעילים אלא אם הקלט קטן.

## אנליזה אסימפטוטית

כאשר אנו משתמשים ב‑Big‑O אנחנו מתעניינים בגרועה מבין האפשרויות (Worst‑Case). לפעמים יש גם **מקרה ממוצע** ו‑**מקרה הטוב**. אך בדרך כלל נרצה לוודא שגם במצב הגרוע ביותר האלגוריתם אינו איטי מדי.

<div class="mermaid">
graph LR
    O1["O(1)"] --> Ologn["O(log(n))"] --> On["O(n)"] --> Onlogn["O(n·log(n))"] --> On2["O(n²)"] --> Oexp["O(2ⁿ)"]
</div>

הדיאגרמה משווה בין סיבוכויות שונות. ככל שהגודל n גדל, ההבדל בין O(n) לבין O(n²) נהיה משמעותי.

## הגדרה לסיבוכיות זמן:
$$O(f(n))$$	זמן ריצה שאינו עולה על הפונקציה $$f(n)$$, עד כדי קבוע.

**ניסוח נוסף:** אינטואיטיבית, הקבוצה $$O(g(n))$$ כוללת את הפונקציות שקצב הגדילה שלהן הוא לכל היותר זה של 
$$g(n)$$ 

**ניסוח קצת יותר פורמלי:** הקבוצה $$O(g(n))$$ הנה קבוצת כל הפונקציות $$f(n)$$ כך ש $$f(n)$$, עבור n גדול מספיק, חסומה מלמעלה ע"י $$c⋅g(n)$$ עבור $$c>0$$ כלשהו.

**הגדרה פורמלית:** 
$$\boxed{O(g(n))=\{f(n)|∃_{c>0,n_{0}>0}∀_{n≥n_{0}}f(n) \leq c·g(n)\}}$$

## דוגמה: השוואת לולאה אחת ולולאה כפולה

נבחן שתי פונקציות שמחשבות סכום של מטריצה מרובעת בגודל n × n. הראשונה משתמשת בלולאה כפולה והשנייה משתמשת בלולאה אחת.

```csharp
// O(n²) סכום מטריצה בשתי לולאות מקוננות – סיבוכיות 
public static int SumMatrixNested(int[,] matrix)
{
    int sum = 0;
    for (int i = 0; i < matrix.GetLength(0); i++)
    {
        for (int j = 0; j < matrix.GetLength(1); j++)
        {
            sum += matrix[i, j];
        }
    }
    return sum;
}

// O(n) סכום מערך חד־ממדי – סיבוכיות
public static int SumArray(int[] row)
{
    int sum = 0;
    for (int i = 0; i < row.Length; i++)
    {
        sum += row[i];
    }
    return sum;
}
```

הפונקציה הראשונה מבצעת n² חיבורי איברים ולכן יש לה סיבוכיות ריבועית. הפונקציה השנייה עוברת על מערך חד־ממדי ולכן היא ליניארית.

## טבלה – קישור בין אלגוריתמים לסיבוכיות

| אלגוריתם | סיבוכיות ריצה | הערות |
| --- | --- | --- |
| חיפוש ליניארי | O(n) | מעבר על כל האיברים עד שמוצאים ערך מסוים |
| חיפוש בינארי | O(log n) | דורש מערך ממויין, חוצה את הטווח לשניים בכל צעד |
| מיון בחירה | O(n²) | שתי לולאות לקביעת מינימום בכל איטרציה |
| Merge Sort | O(n log n) | מחלק את הקלט, ממזג ומחלק שוב |
| מיון בועות | O(n²) | ביצוע החלפות בין איברים סמוכים |
{: .table-rl}

## תרגול וקישורים

כדי לתרגל ניתוח סיבוכיות, נסו לדרג את הסיבוכיות של פונקציות שאתם כותבים. תוכלו למצוא תרגילים נוספים בעמודי התרגול:

{: .leafify}
- [⬅ עברו לתרגיל סיבוכיות פשוטה]({% link cst/2complexity/Ex2.1complexity.easy.md %}#id2a1.1)
- [⬅ עברו לתרגיל סיבוכיות בינונית]({% link cst/2complexity/Ex2.2complexity.lessEasy.md %}#id2a2.2)

<details markdown="1">
<summary>מקום לפתרון</summary>

כתבו פונקציה שמאתרת במערך דו‑ממדי את הערך המקסימלי שקיים בדיוק במחצית מהשורות. נסו לנתח את סיבוכיות הפונקציה שהגדרתם.

</details>
