---
layout: page 
title: "פרק 3 – מחלקת Node<T> ורשימות מקושרות"
subtitle: "מבנה צמתים, חיבור צמתים וג'נריקס"
tags: [Node, רשימה מקושרת, ג'נריקס, צמתים, רשימת מחרוזות, מבנה נתונים]
mathjax: true
lang: he
---

<div class="box-note">
רשימה מקושרת בנויה מצמתים (Node) שכל אחד מהם מחזיק ערך ומצביע לצומת הבא. בפרק זה נעמיק ב‑NodeInt (המכונה גם Bead) ובמחלקה הכללית `Node<T>`, ונלמד להשתמש בג'נריקס לקריאת מבני נתונים גמישים.
</div>

<!-- Source: University of Washington – Linked lists lecture; UF C# Data Structures course -->

### מבוא לרשימות מקושרות

<details markdown="1">
<summary>מהו צומת (Node)?</summary>

בגרסה הפשוטה ביותר, צומת ברשימה מקושרת מכיל שני דברים: נתון (data) ומצביע (next) לצומת הבא. כאשר הצומת האחרון ברשימה מסמן שהמשך הרשימה הוא **null**, הרשימה מסתיימת. כך ניתן להוסיף או להסיר צמתים מבלי להזיז את שאר האיברים כמו במערך.

</details>

#### NodeInt – רשימת מחרוזות

במימוש הפרטי שלנו יש מחלקה בשם **NodeInt** (הידועה גם בשם **Bead**) המקשרת בין מחרוזות. המחלקה מספקת את התכונות הבאות:

| Method | תיאור בעברית |
| --- | --- |
| `NodeInt(string value, NodeInt next)` | קונסטרוקטור ליצירת צומת עם ערך מחרוזת והפניה לצומת הבא |
| `string GetValue()` | מחזיר את הערך השמור בצומת |
| `NodeInt GetNext()` | מחזיר את הצומת הבא |
| `void SetNext(NodeInt next)` | משנה את הצומת הבא לצומת נתון |
| `override string ToString()` | מחזיר מחרוזת המייצגת את שרשרת הצמתים מתחילת הרשימה |
{: .table-rl}

בצומת מסוג **NodeInt** ניתן לשנות את הקישור לצומת הבא באמצעות `SetNext`, להוסיף צומת חדש בראש הרשימה על ידי יצירת צומת חדש שהמצביע שלו מצביע לראש הקודם, או להסיר צומת על ידי דילוג עליו בהגדרת המצביע. בגלל שאין לנו גישה ישירה לאינדקסים, יש לשמור מצביע לראש הרשימה בכל זמן.

#### גנריקס – `Node<T>`;

במקום לעבוד רק עם מחרוזות, אנו עושים שימוש במחלקה **`Node<T>`** שמחזיקה משתנה מסוג כללי `T`. גישה זו מאפשרת לשמור כל סוג אובייקט ברשימה מבלי לכתוב קוד נפרד לכל סוג. להלן מימוש אפשרי ב‑#C:

```csharp
public class Node<T>
{
    public T Value { get; set; }
    public Node<T> Next { get; set; }

    public Node(T value, Node<T> next = null)
    {
        Value = value;
        Next = next;
    }
}

// שימוש במחלקה
Student first = new Student("Alice", 90);
Node<Student> head = new Node<Student>(first);
head.Next = new Node<Student>(new Student("Bob", 75));
```

המחלקה מוגדרת כך שהערך מסוג `T` ואנו יכולים להגדיר טיפוס אחר לכל רשימה. בעזרת גנריקס ניתן להשתמש במחלקה מבלי לדעת מראש מהו סוג הנתונים.

#### דיאגרמה – רשימה מקושרת

<div class="mermaid">
graph LR
    A([ראש]) --> B[Node< T >: Value1]
    B --> C[Node< T >: Value2]
    C --> D[Node< T >: Value3]
    D --> E([null])
</div>

הדיאגרמה מתארת רשימה מקושרת שבה כל צומת מצביע לצומת הבא, והצומת האחרון מצביע ל‑null.

### פעולות נפוצות על רשימה מקושרת

הנה רשימה של פעולות שמחלקות NodeInt ו‑Node&lt;T&gt; תומכות בהן. כל פעולה מוצגת באנגלית ובפירוש בעברית.

| Method | תפקיד |
| --- | --- |
| `Append(Node<T> head, T value)` | מוסיף צומת עם ערך חדש לסוף הרשימה |
| `Prepend(ref Node<T> head, T value)` | מוסיף צומת חדש לראש הרשימה ומעדכן את הראש |
| `int Count(Node<T> head)` | מחזיר את מספר הצמתים ברשימה |
| `bool Contains(Node<T> head, T value)` | בודק אם ערך קיים ברשימה |
| `Node<T> Remove(Node<T> head, T value)` | מסיר את הצומת הראשון בעל ערך נתון ומחזיר את הראש המעודכן |
| `void InsertAfter(Node<T> node, T value)` | מוסיף צומת חדש לאחר צומת נתון |
{: .table-rl}

#### דגשים לג'נריקס

{: .subq}
א. המימוש שלנו משתמש בג'נריקס לקריאה וכתיבה של צמתים עם כל סוג נתונים מבלי להגדיר מחלקה חדשה.  

{: .subq}
ב. אתם עדיין **לא** נדרשים לכתוב מחלקות גנריות משלכם; מטרת הפרק היא ללמוד להשתמש בהן.  

{: .subq}
ג. שימו לב ששימוש במצביע שאינו מאותחל (`null`) עלול לגרום לחריגת `NullReferenceException`.  

### תרגול וקישורים

נסו לממש מספר מתודות על רשימה מקושרת ולהשתמש בג'נריקס. בנוסף, תוכלו למצוא תרגילים בעמודי התרגול הבאים:

* [⬅ עברו לתרגיל 3a0.2 יצירת חרוזים ממערך Beads בסיסי]({% link cst/3nodeNbead/Ex3a0beads.md %}#3a0.2)
* [⬅ עברו לתרגיל 3a1.2 מחלקת Node בסיסית. בניית שרשרת מ-1 עד n]({% link cst/3nodeT/Ex3a1node.md %}#3a1.2)
* [⬅ עברו לתרגיל כמות הזוגיים 3a2.6]({% link cst/3nodeT/Ex3a2node.md %}#3a2.6)
* [⬅ עברו לתרגיל שרשרת המוכלת בשרשרת אחרת]({% link cst/3nodeT/Ex3a3node.md %}#3a3.1)

<details markdown="1">
<summary>מקום לפתרון</summary>

כתבו פונקציה שמקבלת ראש של רשימה מקושרת ומחזירה רשימה חדשה המכילה את אותה רשימה אך בסדר הפוך (reverse). השתמשו בג'נריקס.

</details>
