<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Stack Animation</title>
  <link href="https://fonts.googleapis.com/css?family=Varela+Round&display=swap" rel="stylesheet">
  <!-- Varela Round font -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
    integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <link
    href="data:image/x-icon;base64,AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAADh/wAAAKr/AAAAAAAA//8A0AD/AAAA/wD/DQAAAP9iAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiJEQiJEQiJERGZkRGZkRGZmAAZmAAZmAAB3cAB3cAB3dzM3dzM3dzMzERMzERMzERFVURFVURFVVSIlVSIlVSIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiL//wAA//8AAP//AAD//wAA444AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABxxAAD//wAA//8AAP//AAD//wAA"
    rel="icon" type="image/x-icon">
  <!-- Bootstrap CSS -->
  <style>
    html {
      font-size: 3em;
    }

    body {
      padding: 0.5em;
      font-family: 'Varela Round', sans-serif;
      /* font-size: 1.5em; */
      text-align: center;
      direction: rtl;
      /* Keep the direction RTL as you have it */
    }

    h4 {
      /* font-size: 0.7em; */
      direction: rtl;
    }

    .stack-container,
    .temp-stack-container {
      display: flex;
      flex-direction: column-reverse; /* show top at the top visually */
      justify-content: flex-start;
      align-items: center;
      margin-bottom: 10px;
      direction: ltr;
      width: 8em;
      margin-left: auto;
      margin-right: auto;
    }

    .container {
      border: 0.05em solid salmon;
      border-radius: 0.4em;
      margin-bottom: 0.4em;
      min-height: 7em;
    }

    .stack-item,
    .temp-stack-item {
      font-size: 1.8em;
      width: 2.2em;
      height: 1.6em;
      min-height: 1.6em;
      border: 0.05em solid black;
      border-radius: 0.2em;
      margin: 0.1em;
      /* Rounded corners */
      display: flex;
      justify-content: center;
      align-items: center;
      /* margin-right: 5px; */
    }

    .temp-stack-container {
      margin-top: 20px;
    }

    .btn {
      line-height: 0.8;
    }
.btn-sm {
  font-size: 0.5em;
}
    /* Center the buttons within their container */
    .button-container {
      text-align: center;
      /* This centers the inline elements (buttons) */
      margin: auto;
      padding: 0.3em;
      padding-top: 0.0em;
      /* This centers the container itself if it has a set width */
      direction: rtl;
      /* Maintain RTL direction for the buttons */
    }

    .hover-effect {
      background-color: rgb(40, 167, 69);
      /* Example hover background color */
      color: #FFFFFF;
      /* Example text color change */
      /* Add other hover styles as needed */
    }

    @media (max-width: 1600px) {
      html {
        font-size: 2em;
      }
    }
    @media (max-width: 900px) {
      html {
        font-size: 1.5em;
      }
    }
  </style>

</head>

<body>

  <div class="button-container">
    <button id="btn1" class="btn btn-sm btn-outline-light" onclick="resetStack()">איתחול</button>
    <button id="btn2" class="btn btn-outline-success" onclick="popStack()">הוצאה מהמחסנית</button>
    <button id="btn3" class="btn btn-outline-success" onclick="moveAllToTempStack()">העברה למחסנית זמנית</button>
    <button id="btn4" class="btn btn-outline-success" onclick="pushNew()">דחיפה</button>
    <button id="btn5" class="btn btn-outline-success" onclick="startDuplicationCycleStack()">שכפול</button>
    <button id="btn6" class="btn btn-outline-success" onclick="pushNew(1)">דחוף1</button>
    <button id="btn7" class="btn btn-outline-success" onclick="resetStackSimilar()">דומים</button>
  </div>



  <div class="container">
    <h4 id="s1">מחסנית מקורית</h4>

    <div id="stack" class="btn-group, stack-container"></div>
  </div>

  <div class="container">
    <h4 id="temp_dup">מחסנית זמנית</h4>
    <div id="tempStack" class="btn-group, temp-stack-container"></div>
  </div>

  <div class="button-container">
    <a id="link8" class="btn btn-outline-light"
      href="file:///C:/Users/3stra/OneDrive/Documents/OrtCSharp/MergedBagrutAlon.pdf">שאלה</a>
    <a id="link9" class="btn btn-outline-light"
      href="https://docs.google.com/presentation/d/1F4YjUxq7OyWtPCByhn-4XlFWsRrlT0i_RqpAGQzqmCQ/present?usp=sharing">מצגת</a>
  </div>
  <script>
    let stack = [1, 2, 3, 4]; // Initial stack (top is at the end)
    let tempStack = []; // Temporary stack
    const stackContainer = document.getElementById('stack');
    const tempStackContainer = document.getElementById('tempStack');

    // Define an array of colors
    const colors = ['red', 'green', 'blue', 'orange', 'purple'];

    function displayStack() {
      stackContainer.innerHTML = '';
      stack.forEach(item => {
        const element = document.createElement('div');
        element.className = 'stack-item';
        element.textContent = item;
        element.style.backgroundColor = getColorForItemValue(item);
        stackContainer.appendChild(element);
      });
    }

    function displayTempStack() {
      tempStackContainer.innerHTML = '';
      tempStack.forEach(item => {
        const element = document.createElement('div');
        element.className = 'temp-stack-item';
        element.textContent = item;
        element.style.backgroundColor = getColorForItemValue(item);
        tempStackContainer.appendChild(element);
      });
    }

    function resetStackSimilar() {
      stack = [4, 6, 5, 7];
      tempStack = [5, 7, 4, 6];
      displayStack();
      displayTempStack();
      document.getElementById("s1").innerText = "מחסנית S1";
      document.getElementById("temp_dup").innerText = "מחסנית S2";
    }

    function resetStack() {
      stack = [1, 2, 3, 4];
      tempStack = [];
      displayStack();
      displayTempStack();
      document.getElementById("s1").innerText = "מחסנית מקורית";
      document.getElementById("temp_dup").innerText = "מחסנית זמנית";
    }

    function popStack() {
      if (stack.length > 0) {
        stack.pop();
        displayStack();
      }
    }

    let isStackMoving = false; // Global flag to track the moving process.

    function moveAllToTempStack() {
      isStackMoving = true;

      function moveItemToTemp() {
        if (stack.length > 0) {
          let item = stack.pop();
          tempStack.push(item);
          displayStack();
          displayTempStack();
          setTimeout(moveItemToTemp, 700);
        } else {
          isStackMoving = false;
        }
      }

      moveItemToTemp();
    }

    function pushNew(step = 0) {
      // Push a new value: next integer after current top, or 1 if empty
      const nextVal = stack.length > 0 ? Math.max(...stack) + 1 : 1;
      stack.push(nextVal);
      displayStack();
    }

    function startDuplicationCycleStack() {
      document.getElementById("temp_dup").innerText = "מחסנית משוכפלת";

      let stepsCompleted = 0;

      // Move items from main stack to temp stack (preserving LIFO to reverse order visually)
      function moveToTempStack() {
        if (stack.length > 0) {
          const item = stack.pop();
          tempStack.push(item);
          displayStack();
          displayTempStack();
          setTimeout(moveToTempStack, 500);
        } else if (stepsCompleted < 4) {
          setTimeout(duplicateItems, 500);
        }
      }

      // Duplicate from temp: pop from temp, push to main and push back to temp
      function duplicateItems() {
        const item = tempStack.pop();
        if (item !== undefined) {
          stack.push(item);
          tempStack.push(item);
          displayStack();
          displayTempStack();
          stepsCompleted++;
          if (stepsCompleted < 4) {
            setTimeout(duplicateItems, 700);
          }
        }
      }

      moveToTempStack();
    }


    function getColorForItemValue(value) {
      const colors = {
        1: '#FFCCCC', // Light red
        2: '#CCFFCC', // Light green
        3: '#CCCCFF', // Light blue
        4: '#FFFFCC', // Light yellow
        5: '#FFCCCC', // Light red
        6: '#CCFFCC', // Light green
        7: '#CCCCFF', // Light blue
        8: '#FFFFCC', // Light yellow
        // Add more mappings as needed
      };

      return colors[value] || '#FFFFFF'; // Default to white if no specific color is defined
    }

    // ==================================     mouse handling area  ===================
    // ===============================================================================
    // List of element IDs to cycle through
    const elementIds = ['btn1', 'btn2', 'btn3', 'btn4', 'btn5', 'btn6', 'btn7'];
    let currentIndex = 0; // Track the current index of the focused element.
    let lastCycledElement = null; // Track the last element cycled through.

    function switchFocus(direction) {
      // Adjust the current index based on the direction of the mouse wheel.
      if (direction === 'down') {
        currentIndex = Math.max(0, currentIndex - 1);
      } else if (direction === 'up') {
        currentIndex = (currentIndex + 1) % elementIds.length;
      }

      // Focus the current element.
      const currentElement = document.getElementById(elementIds[currentIndex]);
      currentElement.focus();
      lastCycledElement = currentElement; // Update the last cycled element reference.

      // Remove the hover-effect class from the previously focused element if it exists.
      if (lastFocusedElement && lastFocusedElement !== currentElement) {
        lastFocusedElement.classList.remove('hover-effect');
      }

      // // Add the hover-effect class to the newly focused element.
      // currentElement.classList.add('hover-effect');

      // Update the reference to the last focused element.
      lastFocusedElement = currentElement;
    }

    // Add an event listener for the mouse wheel.
    document.addEventListener('wheel', function (event) {
      // Determine the direction of the mouse wheel scroll.
      const direction = event.deltaY < 0 ? 'down' : 'up';
      switchFocus(direction);
      event.preventDefault(); // Prevent the default scrolling behavior.
    });

    let lastFocusedElement = null; // Track the last focused element to remove the hover effect.

    document.addEventListener('contextmenu', function (event) {
      event.preventDefault(); // Prevent the default context menu from showing.

      if (lastCycledElement && elementIds.includes(lastCycledElement.id)) {
        lastCycledElement.click(); // Programmatically click the last cycled element.
        lastCycledElement.focus(); // Set focus to show focus styles.

        // Remove hover-effect class from the previously focused element if it exists
        if (lastFocusedElement) {
          lastFocusedElement.classList.remove('hover-effect');
        }

        // Add hover-effect class to the currently focused element
        if (lastCycledElement.id != 'btn1')
          lastCycledElement.classList.add('hover-effect');

        // Update the reference to the last focused element
        lastFocusedElement = lastCycledElement;
      }
    });

    elementIds.forEach(id => {
      const element = document.getElementById(id);
      element.addEventListener('mouseover', () => {
        if (lastFocusedElement) {
          lastFocusedElement.classList.remove('hover-effect');
          lastFocusedElement = null;
        }
      });
    });
    // ========================= end of mouse handling region.

    // Initial display
    displayStack();
    displayTempStack();
  </script>
</body>

</html>
