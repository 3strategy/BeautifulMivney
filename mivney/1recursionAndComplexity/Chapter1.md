---
layout: page 
title: "פרק 1 – רקורסיה"
subtitle: "היכרות עם חשיבה רקורסיבית ומקרים בסיסיים"
tags: [רקורסיה, בסיס, call stack,מקרה, מחסנית־קריאות, C#, פתרון בעיות]
mathjax: true
lang: he
---

{: .box-note}
רקורסיה היא טכניקה מרכזית במדעי המחשב שבה פונקציה פותרת בעיה על ידי פירוקה לגרסה קטנה יותר של אותה בעיה. חשוב להבדיל בין **מקרה בסיסי** שבו הפונקציה עוצרת, לבין **מקרה רקורסיבי** שבו היא קוראת לעצמה. הבנת עקרונות אלו תלווה אתכם לאורך הקורס .


<!-- Source: UMBC CMSC 202 – Recursion lecture notes -->

## מבוא לרקורסיה

<details markdown="1">
<summary>מהי רקורסיה?</summary>

רקורסיה מתארת תהליך שבו פונקציה קוראת לעצמה לצורך פתרון בעיה. למשל, קביעת סכום של מערך יכולה להתבצע על ידי סכימת האיבר הראשון עם סכום המערך החל מהאיבר השני. כדי להבטיח שהאלגוריתם מסתיים, עלינו להגדיר **מקרה בסיס** – תנאי שבו הפונקציה מחזירה תוצאה ללא קריאה נוספת .

```csharp
// סכום אלמנטים במערך באמצעות רקורסיה
public static int Sum(int[] arr, int index)
{
    // מקרה בסיס – הגענו לסוף המערך
    if (index == arr.Length)
        return 0;

    // מקרה רקורסיבי – מוסיפים את הערך הנוכחי לסכום שאר האיברים
    return arr[index] + Sum(arr, index + 1);
}
```

בקוד זה המקרה הבסיסי הוא כאשר `index` שווה לגודל המערך. המקרה הרקורסיבי מוסיף את האיבר הנוכחי לתוצאה של קריאה מחדש לפונקציה עם אינדקס מתקדם.
</details>

### ✅ מקרים בסיסיים חשובים

{: .subq}
א. מגדירים תנאי עצירה ברור (למשל, גודל אפס או אינדקס מחוץ לתחום).  
{: .subq}
ב. **אין** לקרוא לפונקציה עצמה מתוך המקרה הבסיסי – אחרת נתקע בלולאה אינסופית.  
{: .subq}
ג. ניתן לחשוב על המקרה הבסיסי כעל פתרון לבעיה הפשוטה ביותר האפשרית.  

### ❌ טעויות נפוצות ברקורסיה

{: .subq}
א. שכחת מקרה בסיס – עלולה לגרום ל־StackOverflow.  
{: .subq}
ב. שינוי נתונים משותפים במיקום לא נכון – עלול לגרום לתוצאה שגויה.  
{: .subq}
ג. כתיבת קוד רקורסיבי כאשר פתרון איטרטיבי פשוט וברור יותר.  

## הבנת מחסנית הקריאות

כל קריאה לפונקציה יוצרת רשומת קריאה חדשה במחסנית. כאשר אנחנו קוראים לפונקציה ברקורסיה, נוצרת שרשרת רשומות עד שמגיעים למקרה הבסיס. לאחר מכן הקריאות מסתיימות בסדר הפוך (LIFO), כמו במחסנית.

<div class="mermaid">
graph TD
    A["Sum(arr, 0)"] --> B["Sum(arr, 1)"]
    B --> C["Sum(arr, 2)"]
    C --> D["Sum(arr, 3)"]
    D --> E["Sum(arr, n)"]
    E --> F[0]
</div>

הדיאגרמה ממחישה כיצד הקריאות נערמות עד למקרה בסיס, ומסמנות חזרה עם הערך 0. כל קריאה מחכה לפתרון הקריאה העמוקה יותר לפני שהיא מחזירה את ערכה.

## רקורסיה מול איטרציה

בפעמים רבות ניתן לפתור בעיה הן בשיטה רקורסיבית והן בשיטה איטרטיבית. בשיטה רקורסיבית מקבלים קוד קריא ופשוט לעיתים, אך הוא עלול לבזבז זיכרון עקב שימור מצבי הקריאה במחסנית. אלגוריתם איטרטיבי משתמש בלולאות ויכול להיות יעיל יותר בזיכרון, במיוחד כאשר העומק הרקורסיבי גדול.

### טבלה – השוואה בין רקורסיה לאיטרציה

| מאפיין | רקורסיה | איטרציה |
| --- | --- | --- |
| שימוש בזיכרון | כל קריאה מוסיפה רשומת מחסנית | לרוב שימוש קבוע בזיכרון |
| קריאות חוזרות | קריאה חוזרת לפונקציה עצמה | לולאה (for / while) |
| קריאות מקרה בסיס | חיוני לעצירת הקריאות | אין צורך במקרה בסיס |
| בהירות קוד | לעיתים קריא יותר | לעיתים נדרשות משתנים נוספים |

## תרגול וקישורים

כדי לתרגל את הנושא מומלץ לפתור מספר שאלות רקורסיביות. תוכלו למצוא תרגילים בקישורים הבאים:

- [⬅ עברו לתרגיל סכום ספרות במספר]({% link cst/1recursion/Ex1a.1recursion.misparitNBool.md %}#id1a1.2)
- [⬅ עברו לתרגיל שרשראות ומחרוזות]({% link cst/1recursion/Ex1a.2recursion.strings.md %}#id1a2.3)

בנוסף, נסו לכתוב פונקציה שמחשבת פקטוריאל באופן רקורסיבי ופונקציה שהופכת מחרוזת. התנסו גם בפתרון איטרטיבי והשוו ביניהם.

<details markdown="1">
<summary>מקום לפתרון</summary>

כאן תוכלו להוסיף את קוד הפתרונות שלכם לתרגילים ולבדוק את ההבדל בין רקורסיה לאיטרציה.

</details>
