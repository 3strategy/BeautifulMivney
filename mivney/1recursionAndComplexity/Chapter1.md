---
layout: page 
title: "פרק 1 – רקורסיה"
subtitle: "היכרות עם חשיבה רקורסיבית ומקרים בסיסיים"
tags: [רקורסיה, בסיס, call stack,מקרה, מחסנית־קריאות, C#, פתרון בעיות]
mathjax: true
lang: he
---

{: .box-note}
רקורסיה היא טכניקה מרכזית במדעי המחשב שבה פונקציה פותרת בעיה על ידי פירוקה לגרסה קטנה יותר של אותה בעיה. חשוב להבדיל בין **מקרה בסיסי** שבו הפונקציה עוצרת, לבין **מקרה רקורסיבי** שבו היא קוראת לעצמה. הבנת עקרונות אלו תלווה אתכם לאורך הקורס .


<!-- Source: UMBC CMSC 202 – Recursion lecture notes -->

## מבוא לרקורסיה

<details markdown="1">
<summary>מהי רקורסיה?</summary>

רקורסיה מתארת תהליך שבו פונקציה קוראת לעצמה לצורך פתרון בעיה. למשל, קביעת סכום של מערך יכולה להתבצע על ידי סכימת האיבר הראשון עם סכום המערך החל מהאיבר השני. כדי להבטיח שהאלגוריתם מסתיים, עלינו להגדיר **מקרה בסיס** – תנאי שבו הפונקציה מחזירה תוצאה ללא קריאה נוספת .

```csharp
// סכום אלמנטים במערך באמצעות רקורסיה
public static int Sum(int[] arr, int index)
{
    // מקרה בסיס – הגענו לסוף המערך
    if (index == arr.Length)
        return 0;

    // מקרה רקורסיבי – מוסיפים את הערך הנוכחי לסכום שאר האיברים
    return arr[index] + Sum(arr, index + 1);
}
```


<details markdown="1"><summary>הבנת מחסנית הקריאות</summary>

### הבנת מחסנית הקריאות

כל קריאה לפונקציה יוצרת רשומת קריאה חדשה במחסנית. כאשר אנחנו קוראים לפונקציה ברקורסיה, נוצרת שרשרת רשומות עד שמגיעים למקרה הבסיס. לאחר מכן הקריאות מסתיימות בסדר הפוך (LIFO), כמו במחסנית.

<div class="mermaid">
graph TD
    A["Sum(arr, 0)"] --> B["Sum(arr, 1)"]
    B --> C["Sum(arr, 2)"]
    C --> D["Sum(arr, 3)"]
    D --> E["Sum(arr, n)"]
    E --> F[0]
</div>

הדיאגרמה ממחישה כיצד הקריאות נערמות עד למקרה בסיס, ומסמנות חזרה עם הערך 0. כל קריאה מחכה לפתרון הקריאה העמוקה יותר לפני שהיא מחזירה את ערכה.

</details>

בקוד זה המקרה הבסיסי הוא כאשר `index` שווה לגודל המערך. המקרה הרקורסיבי מוסיף את האיבר הנוכחי לתוצאה של קריאה מחדש לפונקציה עם אינדקס מתקדם.

</details>

### ✅ מקרים בסיסיים חשובים

{: .subq}
א. מגדירים תנאי עצירה ברור (למשל, גודל אפס או אינדקס מחוץ לתחום).  

{: .subq}
ב. **אין** לקרוא לפונקציה עצמה מתוך המקרה הבסיסי – אחרת נתקע בלולאה אינסופית.  

{: .subq}
ג. רצוי לחשוב על המקרה הבסיסי כעל פתרון לבעיה הפשוטה ביותר האפשרית.  


## תרגול: מכפלה של שני מספרים באופן רקורסיבי
כתבו את הפונקציה `Mul(int a, int b)` המחשבת כפל של $$a·b$$ ברקורסיה. 

הרעיון: $$a⨯b = a+a+ ... b פעמים$$

הדרכה. חשבו על המקרה בו עלינו לכפול 4 ב-1, או בעצם, אפילו 4 ב-0, **כעל המקרה הפשוט**. זה ישמש תנאי עצירה

כיצד נחשב כפל של 4 ב-2 אם אנחנו יודעים כמה זה כפל ב-1?



<details markdown="1"><summary>פתרון</summary>

```csharp
public static int Mul(int a, int b)
{
  if (b == 0) 
    return 0; // תנאי עצירה
  return a + Mul(a, b - 1); // חזרה עם הקטנת b
}
```

</details>

<details markdown="1"><summary>מעקב בשיטת המלבנים</summary>


<div class="mermaid">

flowchart TD
A["Mul(4,3)
(b==0? false)
return 4 + Mul(4,2)"] -->|קריאה רקורסיבית| B["Mul(4,2)
(b==0? false)
return 4 + Mul(4,1)"]
B -->|קריאה רקורסיבית| C["Mul(4,1)
(b==0? false)
return 4 + Mul(4,0)"]
C -->|קריאה רקורסיבית| D["Mul(4,0)
(b==0? true)
return 0"]


D -.->|חזרה: 0| C
C -.->|חזרה: 4| B
B -.->|חזרה: 8| A
A -.->|תוצאה: 12| OUT(("Mul(4,3) = 12"))


</div>

{: .box-success }
**מעקב רקורסיה** בשיטת המלבנים: בשורה העליונה – שם הפונקציה והארגומנטים, בשורה האמצעית – תנאי העצירה, ובשורה השלישית – ביטוי ה־ `return`.  
בחיצים: **→** (חץ מלא) מציין *קריאה רקורסיבית (הלוך)*, ו־**-.->** (חץ מקווקו) מציין *החזרת ערך (חזור)*. במעקב שלהלן הכפל $$4·3$$


</div>



### ❌ טעויות נפוצות ברקורסיה

{: .subq}
א. שִׁיכְחַת מקרה בסיס – תגרום ל־StackOverflow.  

{: .subq}
ב. שינוי נתונים משותפים במיקום לא נכון – עלול לגרום לתוצאה שגויה. לא רלוונטי עבורנו. לא נשתף נתונים. לא נבצע Memoization.

{: .subq}
ג. כתיבת קוד רקורסיבי כאשר פתרון איטרטיבי פשוט וברור יותר. לא רלוונטי עבורנו. ביקשו רקורסיה - יקבלו רקורסיה.



## 2 מנה של חלוקה שלמה בחיסור חוזר – דוגמה: $$(\lfloor (9/4) \rfloor = 2)$$

רעיון: כמה פעמים ניתן לחסר את b מתוך a עד שהמספר קטן מ־b.

```csharp
public static int Div(int a, int b)
{
    if (a < b) 
        return 0;       // תנאי עצירה
    return 1 + Div(a - b, b);  // חזרה עם חיסור b
}
```

**עקיבה גרפית (Mermaid, “מלבנים”):**

<div class="mermaid">

flowchart TD
X["Div(9,4) 
(a < b? false)
return 1 + Div(5,4)"] -->|קריאה רקורסיבית| Y["Div(5,4)
(a < b? false)
return 1 + Div(1,4)"]
  Y -->|קריאה רקורסיבית| Z["Div(1,4)
(a < b? true)
return 0"]

  Z -.->|חזרה: 0| Y
  Y -.->|חזרה: 1| X
  X -.->|תוצאה: 2| OUT2(("Div(9,4) = 2"))

</div>
  
**שיטת המלבנים (סיכום קצר):**
- שורה עליונה: שם הפונקציה והארגומנטים שקיבלה.
- שורה אמצעית: תנאי העצירה (כאן עד ההגעה לבסיס הוא **false**).
- שורה שלישית: `return` עם הקריאה הרקורסיבית/הביטוי.
- חץ מלא = *הלוך* (קריאה), חץ מקווקו = *חזור* (החזרת ערך).

---

## לתרגול עצמי של מעקב (בפעם אחרת)

- שרטט/י מעקב עבור `Mul(3,2)` ו־`Div(10,3)` והוסיפ/י תוויות על ערכי ההחזרה בכל שלב.
- כמה קריאות/חזרות יש בכל אחד מהמקרים? הסבירו בקצרה כיצד נובע המספר מהפרמטרים.



## סרטון על טכניקות לחשיבה רקורסיבית
{% include youtube.html id="ngCos392W4w" %} 

## השלבים של Reductible
1. מה המקרה הפשוט ביותר? הוא ישמש כתנאי העצירה
1. עבודה עם דוגמאות פשוטות, סמוכות למקרה הבסיס, ויזואליציה של הבעיה
1. קישור בין בעיה גדולה לבעיות קטנות יותר. כיצד ניתן לפתור מקרה אם ידוע מקרה קטן יותר?
1. הכללת הקשר שמצאנו
1. כתיבת קוד: תנאי העצירה ואחריו הקריאה הרקורסיבית.


## רקורסיה מול איטרציה

בפעמים רבות ניתן לפתור בעיה הן בשיטה רקורסיבית והן בשיטה איטרטיבית. בשיטה רקורסיבית מקבלים קוד קריא ופשוט לעיתים, אך הוא עלול לבזבז זיכרון עקב שימור מצבי הקריאה במחסנית. אלגוריתם איטרטיבי משתמש בלולאות ויכול להיות יעיל יותר בזיכרון, במיוחד כאשר העומק הרקורסיבי גדול.

### טבלה – השוואה בין רקורסיה לאיטרציה

| מאפיין | רקורסיה | איטרציה |
| --- | --- | --- |
| שימוש בזיכרון | כל קריאה מוסיפה רשומת מחסנית | לרוב שימוש קבוע בזיכרון |
| קריאות חוזרות | קריאה חוזרת לפונקציה עצמה | לולאה (for / while) |
| קריאות מקרה בסיס | חיוני לעצירת הקריאות | אין צורך במקרה בסיס |
| בהירות קוד | לעיתים קריא יותר | לעיתים נדרשות משתנים נוספים |
{: .table-he}

## תרגול וקישורים

כדי לתרגל את הנושא מומלץ לפתור מספר שאלות רקורסיביות. תוכלו למצוא תרגילים בקישורים הבאים:

- [⬅ עברו לתרגיל סכום ספרות במספר]({% link cst/1recursion/Ex1a.1recursion.misparitNBool.md %}#id1a1.2)
- [⬅ עברו לתרגיל שרשראות ומחרוזות]({% link cst/1recursion/Ex1a.2recursion.strings.md %}#id1a2.3)

בנוסף, נסו לכתוב פונקציה שמחשבת פקטוריאל באופן רקורסיבי ופונקציה שהופכת מחרוזת. התנסו גם בפתרון איטרטיבי והשוו ביניהם.


