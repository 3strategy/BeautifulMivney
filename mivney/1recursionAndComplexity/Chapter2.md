---
layout: page 
title: "פרק 2 – יעילות וסיבוכיות"
subtitle: "הבנת זמן ריצה, משאבים ו‑Big‑O"
tags: [סיבוכיות, יעילות, BigO, זמן ריצה, אנליזה אסימפטוטית, מדעי המחשב]
mathjax: true
lang: he
---

{: .box-note}
כאשר מנתחים מבני נתונים ואלגוריתמים חשוב לדעת לא רק מה הם עושים אלא גם כמה משאבים הם צורכים. בפרק זה נלמד להעריך את **יעילות** האלגוריתם (כמה זמן וזיכרון הוא צורך בפועל) ולמדוד את **סיבוכיותו** – תיאור אסימפטוטי של התלות בגודל הקלט.


<!-- Source: University of Wisconsin – Complexity & Big‑O notes; University of Tennessee – Big‑O overview -->
<!-- https://pages.cs.wisc.edu/~vernon/cs367/notes/3.COMPLEXITY.html#:~:text=An%20important%20question%20is%3A%20How,covers%20lots%20of%20resources%2C%20including -->

<!-- https://userpages.cs.umbc.edu/chang/cs202.f98/readings/recursion.html#:~:text=Recursion%20is%20a%20technique%20that,sum%20of%20that%20many%20numbers -->

## מה ההבדל בין יעילות לסיבוכיות?

<details markdown="1">
<summary>הגדרת יעילות - מושג אמורפי שלא צריך לדעת</summary>

**יעילות:(לא צריך לדעת)** (Performance) בודקת את הזמן, הזיכרון ומשאבים אחרים שהאלגוריתם צורך במערכת מסוימת. למשל, כמה שניות לוקח לאלגוריתם לרוץ על מחשב ספציפי וכמה זיכרון RAM הוא משתמש. יעילות מושפעת מפרטי החומרה, שפת התכנות ומהמימוש.

[הערך בויקיפדיה]("https://he.wikipedia.org/wiki/%D7%99%D7%A2%D7%99%D7%9C%D7%95%D7%AA_%D7%90%D7%9C%D7%92%D7%95%D7%A8%D7%99%D7%AA%D7%9E%D7%99%D7%AA#:~:text=%D7%91%D7%9E%D7%93%D7%A2%D7%99%20%D7%94%D7%9E%D7%97%D7%A9%D7%91%2C%20%D7%99%D7%A2%D7%99%D7%9C%D7%95%D7%AA%20%D7%90%D7%9C%D7%92%D7%95%D7%A8%D7%99%D7%AA%D7%9E%D7%99%D7%AA,%D7%99%D7%A9%20%D7%9C%D7%A6%D7%9E%D7%A6%D7%9D%20%D7%90%D7%AA%20%D7%94%D7%A9%D7%99%D7%9E%D7%95%D7%A9%20%D7%91%D7%9E%D7%A9%D7%90%D7%91%D7%99%D7%9D.")


</details>

<details open markdown="1">
<summary>הגדרת סיבוכיות. מושג חשוב שצריך לדעת</summary>

**סיבוכיות** היא מדד תאורטי המתאר כיצד זמן הריצה או השימוש במשאבים גדל עם גודל הקלט. סיבוכיות נמדדת לרוב ב‑Big‑O, המתארת חסם עליון אסימפטוטי – כלומר, איך האלגוריתם מתנהג כאשר גודל הקלט שואף לאינסוף. סיבוכיות אינה תלויה בפרטי החומרה.

[סימון אסימפטוטי - ויקיפדיה $$Big O notation$$](https://he.wikipedia.org/wiki/%D7%A1%D7%99%D7%9E%D7%95%D7%9F_%D7%90%D7%A1%D7%99%D7%9E%D7%A4%D7%98%D7%95%D7%98%D7%99)


</details>

### נתבונן בכמה פונצקיות ונסתכל איך הן גדלות
<a href="https://www.geogebra.org/classic/fewgtr4n" target="_blank">
  <img src="/assets/img/asymptotics0.png" alt="אסימפטוטיקה ההתחלה">
</a>

<a href="https://www.geogebra.org/classic/fewgtr4n" target="_blank">
  ⬅ מעבר לגאוגברה
</a>

### סיבוכיויות זמני ריצה נפוצות

{: .subq}
א. **O(1) – זמן קבוע:** זמן הריצה אינו תלוי בגודל הקלט. למשל, גישה לאיבר במערך לפי אינדקס.  
{: .subq}
ב. **O(log n) – לוגריתמית:** פעולות שמקטינות את הבעיה פי שניים בכל צעד, כמו חיפוש בינארי.  
{: .subq}
ג. **O(n) – ליניארית:** זמן הריצה גדל ביחס ישיר לגודל הקלט – למשל מעבר על כל איברי המערך.  
{: .subq}
ד. **O(n log n) – ליניארי לוגריתמי:** אלגוריתמים מהירים למיון (כמו Merge Sort).  
{: .subq}
ה. **O(n²) – ריבועית:** אלגוריתמים שמבצעים לולאה בתוך לולאה (כמו Bubble Sort).  
{: .subq}
ו. **גדולות יותר:** O(2ⁿ) או O(n!) – בדרך כלל לא יעילים אלא אם הקלט קטן (כמו פיבונאצ'י או מגדלי הנוי ברקורסיה ללא Memoization)



## אנליזה אסימפטוטית

כאשר אנו משתמשים ב‑Big‑O אנחנו מתעניינים בגרועה מבין האפשרויות (Worst‑Case). לפעמים יש גם **מקרה ממוצע** ו‑**מקרה הטוב**. אך בדרך כלל נרצה לוודא שגם במצב הגרוע ביותר האלגוריתם אינו איטי מדי.

<div class="mermaid">
graph LR
    O1["O(1)"] --> Ologn["O(log(n))"] --> On["O(n)"] --> Onlogn["O(n·log(n))"] --> On2["O(n²)"] --> Oexp["O(2ⁿ)"]
</div>

הדיאגרמה משווה בין סיבוכויות שונות. ככל שהגודל n גדל, ההבדל בין O(n) לבין O(n²) נהיה משמעותי.


## כיצד לקבוע מה הסיבוכיות Big O 

- שיטה כואבת - **בהתחלה**: נספור את הצעדים במדוייק ונגדיר פונקציית זמן ריצה. כמה צעדי חישוב נדרשים.
- בהמשך - נשאל את עצמנו כיצד זמן הריצה גדל כאשר הקלט גדל. האם היחס הוא לינארי (לדוגמא כאשר הקלט גדל פי 2 כמות הצעדים תגדל פי 2), או שהיחס הוא ריבועי? (כלומר, כאשר הקלט גדל פי 2 זמן הריצה יגדל פי 4?)
- תמיד:
    - נתחייחס למקרה הגרוע ביותר
    - נתחשב **בגורם המשפיע** ביותר **ונתעלם מהקבוע**: למשל אם מספר הצעדים הוא $$5n^2+2n+7$$ הסיבוכיות תהיה $$O(n^2)$$. אם מספר הצעדים הוא $$3n$$ הסיבוכיות היא $$O(n)$$


## למה הנושא הכללי הוא אסימפטוטיקה?
<a href="https://www.geogebra.org/classic/vz8hzrxn" target="_blank">
  <img src="/assets/img/imageAsymptote.png" alt="אסימפטוטיקה">
</a>

<a href="https://www.geogebra.org/classic/vz8hzrxn" target="_blank">
  ⬅ מעבר לגאוגברה
</a>



## הגדרה לסיבוכיות זמן ריצה:
$$O(f(n))$$	זמן ריצה שאינו עולה על הפונקציה $$f(n)$$, עד כדי קבוע.

**ניסוח נוסף:** אינטואיטיבית, הביטוי $$O(g(n))$$ מתאר את קבוצת הפונקציות שקצב הגדילה שלהן הוא לכל היותר זה של $$g(n)$$ 

**ניסוח קצת יותר פורמלי:** הקבוצה $$O(g(n))$$ הנה קבוצת כל הפונקציות $$f(n)$$ כך ש $$f(n)$$, עבור n גדול מספיק, חסומה מלמעלה ע"י $$c⋅g(n)$$ עבור $$c>0$$ כלשהו.

**הגדרה פורמלית:** 
$$\boxed{O(g(n))=\{f(n)|∃_{c>0,n_{0}>0}∀_{n≥n_{0}}f(n) \leq c·g(n)\}}$$

## דוגמה: השוואת לולאה אחת ולולאה כפולה

נבחן שתי פונקציות שמחשבות סכום של מטריצה מרובעת בגודל n × n. הראשונה משתמשת בלולאה כפולה והשנייה משתמשת בלולאה אחת.

```csharp
// O(n²) סכום מטריצה בשתי לולאות מקוננות – סיבוכיות 
public static int SumMatrixNested(int[,] matrix)
{
    int sum = 0;
    for (int i = 0; i < matrix.GetLength(0); i++)
    {
        for (int j = 0; j < matrix.GetLength(1); j++)
        {
            sum += matrix[i, j];
        }
    }
    return sum;
}

// O(n) סכום מערך חד־ממדי – סיבוכיות
public static int SumArray(int[] row)
{
    int sum = 0;
    for (int i = 0; i < row.Length; i++)
    {
        sum += row[i];
    }
    return sum;
}
```

הפונקציה הראשונה מבצעת n² חיבורי איברים ולכן יש לה סיבוכיות ריבועית. הפונקציה השנייה עוברת על מערך חד־ממדי ולכן היא ליניארית.

## טבלה – קישור בין אלגוריתמים לסיבוכיות

| אלגוריתם | סיבוכיות ריצה | הערות |
| --- | --- | --- |
| חיפוש ליניארי | O(n) | מעבר על כל האיברים עד שמוצאים ערך מסוים |
| חיפוש בינארי | O(log n) | דורש מערך ממויין, חוצה את הטווח לשניים בכל צעד |
| מיון בחירה | O(n²) | שתי לולאות לקביעת מינימום בכל איטרציה |
| Merge Sort | O(n log n) | מחלק את הקלט, ממזג ומחלק שוב |
| מיון בועות | O(n²) | ביצוע החלפות בין איברים סמוכים |
{: .table-rl}

## תרגול וקישורים

כדי לתרגל ניתוח סיבוכיות, נסו לדרג את הסיבוכיות של פונקציות שאתם כותבים. תוכלו למצוא תרגילים נוספים בעמודי התרגול:

{: .leafify}
- [⬅ עברו לתרגיל סיבוכיות פשוטה]({% link cst/2complexity/Ex2.1complexity.easy.md %}#id2a1.1)
- [⬅ עברו לתרגיל סיבוכיות בינונית]({% link cst/2complexity/Ex2.2complexity.lessEasy.md %}#id2a2.2)

<details markdown="1">
<summary>מקום לפתרון</summary>

כתבו פונקציה שמאתרת במערך דו‑ממדי את הערך המקסימלי שקיים בדיוק במחצית מהשורות. נסו לנתח את סיבוכיות הפונקציה שהגדרתם.

</details>

